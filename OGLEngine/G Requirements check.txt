UI (module 2):

To pass (G), complete the following tasks:
+ UI Framework set up (imgui or other alternative) --> (IMGUI)

+ Implement Entity and EntityManager classes --> (GAMEOBJECT AND GAMEOBJECTMANAGER)

+ Ability to manipulate Entity name, model, texture, position, rotation in the UI --> (CHECK)

+ Ability to render all entities --> (CHECK)

+ .obj-file loader implemented, including Vertices and Faces --> (CHECK)

+ Implement MeshManager which can load meshes, cache and re-use them --> (CHECK)

+ Write a small Game Engine Architecture document (2 pages minimum) --> (CHECK, will add to it as times goes on)

-+ Implement Message class, including 2 sub-classes, and use them in at least 1 communication pattern between Managers in your project.
	//I'm now going to analyse above requirement: Message class. Subclasses of Message class, 
	//i.e. classes deriving from Message class. Use the subclasses in at least 1 communication pattern, 
	//observer pattern or mediator pattern I presume, between two managers in your project. Send and receive messages between two managers.

+ Implement the MessageQueue functions in at least 1 Manager and demonstrate usage. --> (MESHMANAGER).
	//I'm now going to analyse above requirement: implement QueueMessage, ProcessMessages and ProcessMessage in one manager.

+ Implement Memory checking functions, use it in one manager's allocations --> (CHECK, MESHMANAGER)

+ Implement serialization (ReadFrom, WriteTo file) for your Mesh class --> (HANDLED IN OBJREADER)

-+ Implement Thread and Mutex functionality and run one of your message-supported Managers in its own thread, communicating only with messages.
	//I'm now going to QUESTION above requirement: run one of your message-supported Managers in its own thread; 
	//when? Only run it in a thread when I need it to, i.e. when calling a function from it, or run it continuously in a thread? 
	//How would that work? How would I make sure a singleton always runs its functions in its own thread?

+ Implement a Camera class and UI to configure it for rendering your scene --> (CHECK, UI PART IN EDITORGUI)

+ Integrate one Texture-loader of choice (besides glfw) --> (STB_IMAGE)
 


To pass with distinction (VG), complete 3 or more bonus tasks:
- Extend .obj-file loader to load UVs, Normals and support Triangulization
- Implement iterative resource (.obj-file or texture) loading to support loading huge files in single-threaded contexts
-+ Implement a Camera Manager and ability to switch between different cameras, as well as key-bindings for simple camera movement (WSAD, arrow keys) --> (CHECK, camera movement implemented, but not multiple cameras if I don't count from lights point of view when generating shadow maps.)
- Implement your own PNG-loader using zlib
- Implement serialization for your scene/level (Entities, meta-data)









GRAPHICS (module 3):

To pass (G), complete the following tasks:
+ Update Obj loader to support loading and buffering UVs and Normals to OpenGL --> (CHECK, modifications to ObjReader and addition of vboindexer, also BufferMesh() in Mesh class.)

+ Implement usage of Diffuse/Albedo maps and Specular (shininess) maps, including UI to set per entity and using in shader --> (CHECK)

- Add MipMap settings (scene-wide, or per entity)

+ Implement Phong shader, supporting multiple lights and light types --> (CHECK)

+ Add 3 different types of lights to your scene, Point, Directional, Spot light --> (CHECK, can't save scenes at the moment so I have to add them manually every time.)

-+ Add UI to configure all light properties, Create and Delete --> (CHECK, create and delete happens when I add/remove (NEED TO FIX REMOVE ISSUE) a LightComponent and also when I change the light type in its properties.)

-+ Implement either: Shadow mapping, or Deferred Rendering --> (CHECK, shadowmapping being worked on)


REMEMBER TO UPDATE GAME ENGINE ARCHITECTURE DOCUMENT BEFORE MONDAY 27 JANUARY.

 
To pass with distinction (VG), in addition to the above, complete one of the following:
- Implement normal mapping
- Implement render pipeline supporting both Shadow Mapping and Deferred Rendering combined
- Implement Blend shapes/Morph targets
- Implement Frustum Culling
 
.. and 2 or more bonus tasks:
- Add possibility to reload shaders in run-time using a key-binding or button
- Add a toggle to switch between a Flat shader and the Phong shader for your scene (Flat just samples albedo)
- Add a toggle to render your lights as wireframes
+ Add possibility to attach a light to an entity via a LightProperty --> (CHECK, in my case the LightProperty would be a LightComponent.)
- Use Uniform Buffer Objects to enable use of very many lights (requires Deferred)